http://rxmarbles.com - ресурс с операторами в RxJava

Hystrix: библиотека для реализации отказоустойчивых служб (https://
github.com/Netflix/Hystrix);
• Ribbon: библиотека RPC с поддержкой балансировки нагрузки (https://
github.com/Netflix/ribbon);
• Zuul: защищенный и устойчивый шлюз, поддерживающий динамическую маршрутизацию и возможность
мониторинга (https://github.com/
Netflix/zuul);
• RxNetty: реактивный адаптер для Netty, клиент/серверного фреймворка
NIO (https://github.com/ReactiveX/RxNetty).

Чтобы приложение соответствовало принципам реактивного дизайна, мы не
можем использовать старую модель извлечения данных для получения информации.
К счастью, в настоящее время имеется несколько широко распространенных
протоколов для асинхронной передачи сообщений от сервера клиенту, а именно
WebSocket и Server-Sent Events (SSE).

Прежде всего Project Reactor предлагает две реализации интерфейса Publisher<T>:
Flux<T> и Mono<T>.
В отличие от Flux, тип Mono определяет поток данных, который может произвести
не более одного элемента и описывается следующей формулой

Во второй версии RxJava 2.X в библиотеке появились следующие реактивные типы: Observable,
Flowable, Single, Maybe и Completable. Давайте посмотрим, чем они отличаются
и чем похожи на тандем типов Flux/Mono.

Паттерны в реактивном программировании:
1. Iterator, Observer, Publisher/Subscriber

Библиотека поддерживает распространение обратного давления для всех возможных моделей:

[ 144 ]
• PUSH: подписчик запрашивает фактически бесконечное количество элементов
вызовом subscription.request(Long.MAX_VALUE);
• PULL: подписчик запрашивает следующий элемент только после обработки
предыдущего: subscription.request(1);
• PULL-PUSH (иногда эту модель называют смешанной):
подписчик управляет передачей элементов в режиме реального времени,
а издатель подстраивается под заявленную скорость потребления данных.

Кроме того, для адаптации под старый API,
не поддерживающий модель PULL-PUSH,
Reactor предлагает массу классических механизмов управления обратным
давлением, а именно кеширование, кадрирование,
удаление избыточных сообщений, возбуждение исключений и т. д.

Reactive Streams определяет всего четыре интерфейса: Publisher<T>, Subscriber<T>, Subscription и Processor<T, R>.

![img.png](img.png)

Всего
в библиотеке четыре оператора, позволяющих переключать рабочие потоки.
Рассмотрим их по очереди.
Оператор publishOn позволяет перенести этап выполнения потока данных
в конкретный рабочий поток.
![img_1.png](img_1.png)
![img_2.png](img_2.png)

Другим важным фактором поддержки многопоточного выполнения в Reactor является оператор subscribeOn.
В отличие от publishOn, оператор subscribeOn позволяет изменить рабочий поток выполнения,
в котором выполняется часть цепочки, относящаяся к подписке.

Кроме нетривиальных операторов для управления потоками выполнения, в которых должны протекать те или иные этапы
обработки данных, библиотека Reactor
предлагает уже знакомый способ распараллеливания работы. Для этого в Reactor
имеется оператор .parallel, который позволяет разбить один поток данных на
несколько подпотоков и распределить элементы между ними. Вот пример использования этого оператор

![img_3.png](img_3.png)

Планировщики
• SingleScheduler - один рабочий р поток
• ParallelScheduler - фиксированное кол-во р потоков
• ElasticScheduler - кэшированые неограниченный пулл потоков дла i/o

Контекст
Экземпляр Context
доступен через оператора Mono.subscriberContext и может добавляться в поток
данных с использованием оператора subscriberContext(Context).

Слияние операторов
Одно из самых заметных
усовершенствований – это жизненный цикл реактивного потока и слияние
операторов.

Макрослияние -
оптимизации, когда проджект реактор на этапе сборки потока обработки заменяет методы обработк на их отпимизированные
варианты.
Например Flux.just(1).publishOn().map() на subscribeOn()
Вообще, целью оптимизации макрослияния в Project Reactor является оптимизация этапа сборки, чтобы
дать возможность для стрельбы по воробьям вместо пушки использовать более
простое и дешевое оружие.

Микрослияние
икрослияние (micro-fusion) – более сложная оптимизация.
Она связана с оптимизацией этапа выполнения и повторным использованием ресурсов.
Flux.from(factory)
.filter(inspectionDepartment)
.subscribe(store);
ConditionalSubscriber. Он позволяет организовать проверку условия непосредственно на стороне источника и передачу
необходимого количества
элементов без дополнительных вызовов request.
Книга по спринг буту «Preview Online Code Files Learning Spring Boot 2.0, Second Edition», где очень
подробно исследуется Spring Boot.

![img_4.png](img_4.png)

Архитектура реактивного веб-стека

![img_5.png](img_5.png)

Важный вопрос – как число параллельно выполняющихся рабочих потоков влияет на задержку или пропускную
способность?

Чтобы объяснить такое поведение системы, универсальный закон масштабируемости (Universal Scalability Law, USL),
дополняющий закон Амдала, предлагает следующую формулу для вычисления изменения пропускной способности
в зависимости от степени распараллеливания:
![img_6.png](img_6.png)
![img_7.png](img_7.png)
В предыдущей формуле появился новый коэффициент – коэффициент согласования (k). Самое примечательное, что согласно
этому закону пропускная способность X(N) находится в обратной квадратичной зависимости от степени распараллеливания N.

Чтобы обеспечить соответствующую нагрузку на промежуточное ПО и собрать
статистику измерений, используем современный инструмент тестирования производительности –
wrk (https://github.com/wg/wrk).

МИНУСЫ РАСПРЕДЕЛЁННЫЪ ТРАНЗАКЦИЙ

Однако в настоящее время не рекомендуется прибегать к распределенным транзакциям между несколькими микросервисами. Это
обусловлено несколькими причинами. Наиболее важные перечислены ниже:
• служба, поддерживающая распределенные транзакции, должна иметь API
двухфазного подтверждения, реализовать который очень непросто;
• микросервисы, вовлекаемые в распределенную транзакцию, оказываются
чересчур тесно связанными, что явно противоречит идее архитектуры на
основе микросервисов;
• распределенные транзакции не масштабируются, ограничивают пропускную способность системы и соответственно ухудшают
масштабируемость
системы.

СОБЫТИЙНО_ОРИЕНТИРОВАННЫЕ АРХИТЕКТУРЫ
Лучший способ реализовать поддержку распределенных бизнес-транзакций
в окружении микросервисов – создать событийно-ориентированную архитектуру, которую мы уже несколько раз рассматривали в
этой книге.
Если требуется изменить состояние системы, первая служба изменяет свои данные в своей базе данных и в рамках той же
самой внутренней транзакции посылает событие брокеру сообщений. То есть транзакции не пересекают границ службы. Вторая
служба, подписавшаяся на требуемый тип событий, получает события
и изменяет соответственно данные в своем хранилище и, возможно, посылает
свое событие. Службы остаются независимыми друг от друга. Единственное, что
их связывает, – это сообщения, которыми они обмениваются. В отличие от распределенных транзакций,
событийно-ориентированная архитектура позволяет
системе нормально действовать, даже если вторая служба не будет работать, когда первая выполнит действие. Это очень
важная характеристика, потому что она
напрямую влияет на устойчивость системы. Распределенная транзакция требует,
чтобы все вовлеченные компоненты (микросервисы) были доступны и исправно работали, пока она протекает. Чем больше
микросервисов в системе или чем
шире вовлеченность их в распределенные транзакции, тем сложнее такой системе действовать.

<h1>Согласованность в конечном счете</h1>
Давайте оглянемся назад и  посмотрим, какую роль играют распределенные
транзакции в  программной системе. Очевидно, что главная их цель – обеспечить пребывание системы в некотором определенном состоянии. Иначе говоря,
они устраняют неопределенность, которая может быть вызвана несовместимостью состояний разных компонентов системы. Однако такое устранение неопределенности является очень ограничительным требованием. Вон Вернон (Vaughn
Vernon), автор книги «Implementing Domain-Driven Design and Domain-Driven Design
Distilled»5, предложил внедрить неопределенность в  предметную модель. По его
словам, если систему сложно защитить от противоречивого состояния, которое все
равно возникает, сколько бы мы с ним ни боролись, выгоднее будет принять неопределенность и сделать ее частью обычного бизнес-процесса.
Например, наша система могла бы создавать заказ без подтверждения платежа,
вводя новое состояние с названием проверка платежной информации. Это новое событие превращает неопределенное состояние (информация о платеже может подтвердиться или не подтвердиться) в отдельный бизнес-этап, требующий
некоторого времени для завершения (пока информация о платеже не подтвердится). С таким подходом мы не требуем, чтобы система постоянно находилась
в непротиворечивом состоянии. Мы лишь хотим, чтобы система имела непротиворечивое представление о  каждой бизнес-транзакции. Такая непротиворечивость в будущем называется согласованностью в конечном счете. Суть ее иллюстрирует диаграмма на рис. 7.9.

<h1>Шаблон SAGA</h1>
Один из самых популярных шаблонов для реализации распределенных транзакций, особенно в мире микросервисов, называется SAGA (сага). Он был придуман
в 1987 году для управления долгоживущими транзакциями в базах данных.
Сага состоит из нескольких мелких транзакций, каждая из которых является локальной для своего микросервиса. В  этом случае внешний запрос инициирует
сагу и запускает первую небольшую транзакцию, которая при успешном завершении запускает вторую транзакцию и т.д. Если какая-то транзакция в середине терпит неудачу, запускается действие, компенсирующее предыдущие транзакции. Существует два основных способа реализации шаблона  – посредством
регистрации событий и обращением к службе-координатору

<h1>Разделение ответственности на команды и запросы</h1>
Разделение ответственности на команды и запросы (Command Query Responsibility Segregation, CQRS) часто используется в  паре с  регистрацией событий.
Шаблон CQRS состоит из двух частей:
• пишущая часть получает команды изменения состояния и  сохраняет их
в базовом хранилище событий, но не возвращает состояния сущности;
• читающая часть не изменяет состояния сущности и возвращает его в ответ на запросы. Представления состояний для отдельных запросов хранятся отдельно и пересчитываются асинхронно после получения изменяющих 
событий

<h1>Бесконфликтно реплицируемые типы данных</h1>
Чем больше становится наше приложение, тем больше данных оно должно обрабатывать, даже если имеет единственный микросервис с четко ограниченной
областью. Как упоминалось выше, транзакции не поддаются масштабированию,
и  с ростом приложения становится все труднее поддерживать глобальную целостность состояния даже в рамках одного микросервиса. Поэтому для лучшей
производительности и  масштабируемости системы мы можем разрешить конкурентное изменение данных разными экземплярами службы, отказавшись от
глобальной блокировки или согласования транзакций. Такой подход называется оптимистической репликацией и  позволяет репликам данных развиваться параллельно с возможными несоответствиями, которые должны быть улаже
ны позже. В таких сценариях несогласованность между репликами устраняется
на этапе их слияния. В  этот момент все конфликты между ними должны быть
ликвидированы, но иногда для этого требуется отменить некоторые изменения,
что может быть неприемлемо с точки зрения пользователя. Однако существуют
такие структуры данных, обладающие особыми математическими свойствами,
которые гарантируют успех слияния реплик. Подобные структуры называются
бесконфликтно реплицируемыми типами данных (Conflict-Free Replicated
Data Types, CRDT). <br>
CRDT – это типы данных, которые могут реплицироваться по нескольким вычислительным единицам, изменяться конкурентно без всякой координации и затем
объединяться для приведения в целостное, непротиворечивое состояние. Эта идея
была описана в 2011 году Марком Шапиро (Marc Shapiro), Нуно Прегуиком (Nuno
Preguica), Мареком Завирски (Marek Zawirski) и Карлосом Бакеро (Carlos Baquero).
На момент написания этих строк к CRDT относилось несколько типов данных, таких как «только растущий счетчик», «только расширяющееся множество», «двухфазное множество» Two-Phase Set, «множество – последний записанный побеждает» и  некоторые другие множества, которые могут удовлетворить лишь час
бизнес-требований. Однако типы CRDT полезны для сценариев совместного редактирования текста, онлайн-чатов и азартных онлайн-игр. SoundCloud, платформа распространения звукозаписей, использует CRDT и веб-фреймворк Phoenix для
поддержки обмена информацией между множеством узлов в  режиме реального
времени, а Microsoft Cosmos DB использует CRDT для записи данных. База данных
Redis также имеет встроенную поддержку CRDT в форме бесконфликтно реплицируемой базы данных (Conflict-Free Replicated Database, CRDB).
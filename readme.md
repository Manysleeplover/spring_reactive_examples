http://rxmarbles.com - ресурс с операторами в RxJava

Hystrix: библиотека для реализации отказоустойчивых служб (https://
github.com/Netflix/Hystrix);
• Ribbon: библиотека RPC с поддержкой балансировки нагрузки (https://
github.com/Netflix/ribbon);
• Zuul: защищенный и устойчивый шлюз, поддерживающий динамическую маршрутизацию и возможность мониторинга (https://github.com/
Netflix/zuul);
• RxNetty: реактивный адаптер для Netty, клиент/серверного фреймворка
NIO (https://github.com/ReactiveX/RxNetty).

Чтобы приложение соответствовало принципам реактивного дизайна, мы не
можем использовать старую модель извлечения данных для получения информации. 
К счастью, в настоящее время имеется несколько широко распространенных
протоколов для асинхронной передачи сообщений от сервера клиенту, а именно
WebSocket и Server-Sent Events (SSE).

Прежде всего Project Reactor предлагает две реализации интерфейса Publisher<T>:
Flux<T> и Mono<T>.
В отличие от Flux, тип Mono определяет поток данных, который может произвести
не более одного элемента и описывается следующей формулой

Во второй версии RxJava 2.X в библиотеке появились следующие реактивные типы: Observable,
Flowable, Single, Maybe и Completable. Давайте посмотрим, чем они отличаются
и чем похожи на тандем типов Flux/Mono.

Паттерны в реактивном программировании:
    1. Iterator, Observer, Publisher/Subscriber

Библиотека поддерживает распространение обратного давления для всех возможных моделей:

[ 144 ]
• PUSH: подписчик запрашивает фактически бесконечное количество элементов 
вызовом subscription.request(Long.MAX_VALUE);
• PULL: подписчик запрашивает следующий элемент только после обработки
предыдущего: subscription.request(1);
• PULL-PUSH (иногда эту модель называют смешанной): 
подписчик управляет передачей элементов в режиме реального времени, 
а издатель подстраивается под заявленную скорость потребления данных.

Кроме того, для адаптации под старый API, 
не поддерживающий модель PULL-PUSH, 
Reactor предлагает массу классических механизмов управления обратным
давлением, а именно кеширование, кадрирование, 
удаление избыточных сообщений, возбуждение исключений и т. д.

Reactive Streams определяет всего четыре интерфейса: Publisher<T>, Subscriber<T>, Subscription и Processor<T, R>.

![img.png](img.png)

Всего
в библиотеке четыре оператора, позволяющих переключать рабочие потоки.
Рассмотрим их по очереди.
Оператор publishOn позволяет перенести этап выполнения потока данных
в конкретный рабочий поток.
![img_1.png](img_1.png)
![img_2.png](img_2.png)

Другим важным фактором поддержки многопоточного выполнения в Reactor является оператор subscribeOn. 
В отличие от publishOn, оператор subscribeOn позволяет изменить рабочий поток выполнения, 
в котором выполняется часть цепочки, относящаяся к подписке.

Кроме нетривиальных операторов для управления потоками выполнения, в которых должны протекать те или иные этапы обработки данных, библиотека Reactor
предлагает уже знакомый способ распараллеливания работы. Для этого в Reactor
имеется оператор .parallel, который позволяет разбить один поток данных на
несколько подпотоков и  распределить элементы между ними. Вот пример использования этого оператор

![img_3.png](img_3.png)



Планировщики
• SingleScheduler - один рабочий р поток
• ParallelScheduler - фиксированное кол-во р потоков
• ElasticScheduler - кэшированые неограниченный пулл потоков дла i/o

Контекст
Экземпляр Context
доступен через оператора Mono.subscriberContext и  может добавляться в  поток
данных с использованием оператора subscriberContext(Context).

Слияние операторов
Одно из самых заметных
усовершенствований – это жизненный цикл реактивного потока и  слияние
операторов. 

Макрослияние - 
оптимизации, когда проджект реактор на этапе сборки потока обработки заменяет методы обработк на их отпимизированные варианты.
Например Flux.just(1).publishOn().map() на subscribeOn()
Вообще, целью оптимизации макрослияния в Project Reactor является оптимизация этапа сборки, чтобы
дать возможность для стрельбы по воробьям вместо пушки использовать более
простое и дешевое оружие.

Микрослияние
икрослияние (micro-fusion) – более сложная оптимизация. 
Она связана с оптимизацией этапа выполнения и повторным использованием ресурсов.
Flux.from(factory)
.filter(inspectionDepartment)
.subscribe(store);
ConditionalSubscriber. Он позволяет организовать проверку условия непосредственно на стороне источника и передачу необходимого количества
элементов без дополнительных вызовов request.
Книга по спринг буту «Preview Online Code Files Learning Spring Boot 2.0, Second Edition», где очень
подробно исследуется Spring Boot.

![img_4.png](img_4.png)

Архитектура реактивного веб-стека

![img_5.png](img_5.png)

Важный вопрос – как число параллельно выполняющихся рабочих потоков влияет на задержку или пропускную
способность?

Чтобы объяснить такое поведение системы, универсальный закон масштабируемости (Universal Scalability Law, USL), дополняющий закон Амдала, предлагает следующую формулу для вычисления изменения пропускной способности
в зависимости от степени распараллеливания:
![img_6.png](img_6.png)
![img_7.png](img_7.png)
В предыдущей формуле появился новый коэффициент – коэффициент согласования (k). Самое примечательное, что согласно этому закону пропускная способность X(N) находится в обратной квадратичной зависимости от степени распараллеливания N.



Чтобы обеспечить соответствующую нагрузку на промежуточное ПО и собрать
статистику измерений, используем современный инструмент тестирования производительности – wrk (https://github.com/wg/wrk).

МИНУСЫ РАСПРЕДЕЛЁННЫЪ ТРАНЗАКЦИЙ

Однако в настоящее время не рекомендуется прибегать к распределенным транзакциям между несколькими микросервисами. Это обусловлено несколькими причинами. Наиболее важные перечислены ниже:
• служба, поддерживающая распределенные транзакции, должна иметь API
двухфазного подтверждения, реализовать который очень непросто;
• микросервисы, вовлекаемые в  распределенную транзакцию, оказываются
чересчур тесно связанными, что явно противоречит идее архитектуры на
основе микросервисов;
• распределенные транзакции не масштабируются, ограничивают пропускную способность системы и  соответственно ухудшают масштабируемость
системы.

СОБЫТИЙНО_ОРИЕНТИРОВАННЫЕ АРХИТЕКТУРЫ
Лучший способ реализовать поддержку распределенных бизнес-транзакций
в окружении микросервисов – создать событийно-ориентированную архитектуру, которую мы уже несколько раз рассматривали в этой книге.
Если требуется изменить состояние системы, первая служба изменяет свои данные в своей базе данных и в рамках той же самой внутренней транзакции посылает событие брокеру сообщений. То есть транзакции не пересекают границ службы. Вторая служба, подписавшаяся на требуемый тип событий, получает события
и  изменяет соответственно данные в  своем хранилище и, возможно, посылает
свое событие. Службы остаются независимыми друг от друга. Единственное, что
их связывает, – это сообщения, которыми они обмениваются. В отличие от распределенных транзакций, событийно-ориентированная архитектура позволяет
системе нормально действовать, даже если вторая служба не будет работать, когда первая выполнит действие. Это очень важная характеристика, потому что она
напрямую влияет на устойчивость системы. Распределенная транзакция требует,
чтобы все вовлеченные компоненты (микросервисы) были доступны и  исправно работали, пока она протекает. Чем больше микросервисов в системе или чем
шире вовлеченность их в  распределенные транзакции, тем сложнее такой системе действовать.
